–ò–¥–µ—è —Å–∏–ª—å–Ω–∞—è, –º–Ω–æ–≥–æ—Å–ª–æ–π–Ω–∞—è –∏ ‚Äî —á—Ç–æ –≤–∞–∂–Ω–æ ‚Äî –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–Ω–æ –∂–∏–∑–Ω–µ—Å–ø–æ—Å–æ–±–Ω–∞—è. –ù–∏–∂–µ —Ä–∞–∑–±–µ—Ä—É —á–µ—Å—Ç–Ω–æ –∏ –±–µ–∑ —Ä–µ–∫–ª–∞–º–Ω–æ–≥–æ —Ç—É–º–∞–Ω–∞, –∫–∞–∫ –µ—Å–ª–∏ –±—ã —Ä—É–∫–æ–ø–∏—Å—å –ª–µ–≥–ª–∞ –Ω–∞ —Å—Ç–æ–ª —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞, –∫–æ—Ç–æ—Ä—ã–π –≤–∏–¥–µ–ª —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ–µ –∏ –ø–æ—Ç–æ–º—É —É–∂–µ —Ç—Ä—É–¥–Ω–æ —É–¥–∏–≤–ª—è–µ—Ç—Å—è.

–∞) –ù–∞—Å–∫–æ–ª—å–∫–æ —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–æ

–ö–æ—Ä–æ—Ç–∫–æ: –¥–∞, –≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–æ. –ù–µ –º–∞—Å—Å–æ–≤—ã–π ¬´–ª–æ–∫–æ–º–æ—Ç–∏–≤¬ª, –Ω–æ –æ—á–µ–Ω—å —Ö–æ—Ä–æ—à–∞—è —É–º–Ω–∞—è –ø–æ–ø—É–ª—è—Ä–Ω–∞—è –ø—Ä–æ–∑–∞ —Å –¥–æ–ª–≥–æ–π –∂–∏–∑–Ω—å—é.

–ü–æ—á–µ–º—É:

–§–æ—Ä–º–∞—Ç –±–ª–æ–≥–∞ / –∑–∞–ø–∏—Å–µ–π
–≠—Ç–æ –æ–¥–∏–Ω –∏–∑ —Å–∞–º—ã—Ö –∫–æ–º—Ñ–æ—Ä—Ç–Ω—ã—Ö –¥–ª—è —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª—è —Ñ–æ—Ä–º–∞—Ç–æ–≤. –û–Ω —Å–Ω–∏–º–∞–µ—Ç —Å—Ç—Ä–∞—Ö ¬´–±–æ–ª—å—à–æ–≥–æ —Ä–æ–º–∞–Ω–∞¬ª, –ø–æ–∑–≤–æ–ª—è–µ—Ç —á–∏—Ç–∞—Ç—å —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞—Ä–Ω–æ, –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å—Å—è, –¥–µ–ª–∞—Ç—å –ø–∞—É–∑—ã. 300 —Å—Ç—Ä–∞–Ω–∏—Ü, —Ä–∞–∑–±–∏—Ç—ã–µ –Ω–∞ –ø–æ—Å—Ç—ã, –ø—Å–∏—Ö–æ–ª–æ–≥–∏—á–µ—Å–∫–∏ –æ—â—É—â–∞—é—Ç—Å—è –∫–∞–∫ 180‚Äì220.

–¢–µ–º–∞ –∑–∞–±–æ—Ç—ã –æ —á–µ–ª–æ–≤–µ–∫–µ –±–µ–∑ –Ω–∞–∑–∏–¥–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
–¢—ã –Ω–µ —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–µ—à—å, –∫–∞–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∂–∏—Ç—å. –¢—ã –ø–æ–∫–∞–∑—ã–≤–∞–µ—à—å, –∫–∞–∫ –∂–∏–∑–Ω—å –∏–Ω–æ–≥–¥–∞ —Å–ª–µ–≥–∫–∞ –ø–æ–¥—Ç–∞–ª–∫–∏–≤–∞—é—Ç ‚Äî –∏ —ç—Ç–æ–≥–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ. –°–µ–π—á–∞—Å —ç—Ç–æ —Ä–µ–¥–∫–∞—è –∏ –æ—á–µ–Ω—å –≤–æ—Å—Ç—Ä–µ–±–æ–≤–∞–Ω–Ω–∞—è –∏–Ω—Ç–æ–Ω–∞—Ü–∏—è:
–Ω–µ ¬´–º–æ—Ç–∏–≤–∞—Ü–∏—è¬ª,
–Ω–µ ¬´–ø—Å–∏—Ö–æ–ª–æ–≥–∏—è —É—Å–ø–µ—Ö–∞¬ª,
–∞ —Ç–∏—Ö–æ–µ –±–ª–∞–≥–æ–∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏–µ.

–°–µ–Ω—Å–æ—Ä–Ω–∞—è –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞
–ó–∞–ø–∞—Ö–∏ ‚Äî –ø–æ—á—Ç–∏ –Ω–µ–æ—Å–≤–æ–µ–Ω–Ω–æ–µ –ø–æ–ª–µ. –ó—Ä–µ–Ω–∏–µ –∏ —Å–ª—É—Ö –≤—ã–∂–∞—Ç—ã –¥–æ —Å—É—Ö–æ—Å—Ç–∏. –û–±–æ–Ω—è–Ω–∏–µ ‚Äî –≥–ª—É–±–∏–Ω–Ω–æ–µ, —Ç–µ–ª–µ—Å–Ω–æ–µ, —Å–≤—è–∑–∞–Ω–Ω–æ–µ —Å –ø–∞–º—è—Ç—å—é –∏ –±–µ—Å—Å–æ–∑–Ω–∞—Ç–µ–ª—å–Ω—ã–º. –≠—Ç–æ —Ü–µ–ø–ª—è–µ—Ç —á–∏—Ç–∞—Ç–µ–ª—è —Å–∏–ª—å–Ω–µ–µ, —á–µ–º –æ–Ω –æ–∂–∏–¥–∞–µ—Ç.

–ê–Ω—Ç–∏-—Ü–∏–Ω–∏–∑–º –±–µ–∑ –Ω–∞–∏–≤–Ω–æ—Å—Ç–∏
–ö–Ω–∏–≥–∞ –≤–æ–æ–¥—É—à–µ–≤–ª—è—é—â–∞—è, –Ω–æ –Ω–µ —Å–ª–∞—â–∞–≤–∞—è. –°—É–¥—å–±—ã –º–µ–Ω—è—é—Ç—Å—è –Ω–µ –ø–æ—Ç–æ–º—É, —á—Ç–æ ¬´–º–∏—Ä –¥–æ–±—Ä¬ª, –∞ –ø–æ—Ç–æ–º—É —á—Ç–æ –∫—Ç–æ-—Ç–æ –≤–æ–≤—Ä–µ–º—è –æ–∫–∞–∑–∞–ª—Å—è —Ä—è–¥–æ–º. –≠—Ç–æ –≤–∑—Ä–æ—Å–ª–∞—è –Ω–∞–¥–µ–∂–¥–∞. –°–µ–π—á–∞—Å –æ–Ω–∞ –≤ –¥–µ—Ñ–∏—Ü–∏—Ç–µ.

–ê—É–¥–∏—Ç–æ—Ä–∏—è:

—á–∏—Ç–∞—Ç–µ–ª–∏ –ü–µ–ª–µ–≤–∏–Ω–∞ —Ä–∞–Ω–Ω–µ–≥–æ, –Ω–æ —É—Å—Ç–∞–≤—à–∏–µ –æ—Ç –µ–≥–æ —Ö–æ–ª–æ–¥–∞;

–ø–æ–∫–ª–æ–Ω–Ω–∏–∫–∏ ¬´–º–∞–≥–∏—á–µ—Å–∫–æ–≥–æ —Ä–µ–∞–ª–∏–∑–º–∞ –±–µ–∑ –º–∞–≥–∏–∏¬ª;

–ª—é–¥–∏ 30‚Äì55, –æ—Å–æ–±–µ–Ω–Ω–æ —Ç–µ, –∫—Ç–æ –ø–µ—Ä–µ–∂–∏–ª —Å–ø–∞–¥, —É—Ç—Ä–∞—Ç—É –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏, —Å–ª–∞–≤—ã, —á—É–≤—Å—Ç–≤.

–±) –ù–∞—Å–∫–æ–ª—å–∫–æ —ç—Ç–æ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ –∏ –Ω–∞ —á—Ç–æ –ø–æ—Ö–æ–∂–µ
–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ—Å—Ç—å ‚Äî –≤ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏, –Ω–µ –≤ –æ–¥–Ω–æ–º —ç–ª–µ–º–µ–Ω—Ç–µ

–ü–æ –æ—Ç–¥–µ–ª—å–Ω–æ—Å—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç—ã –∑–Ω–∞–∫–æ–º—ã:

–¥–∞—Ä ‚Üí –µ—Å—Ç—å;

–∑–∞–ø–∞—Ö–∏ ‚Üí –±—ã–ª–∏;

–±–ª–æ–≥ / –¥–Ω–µ–≤–Ω–∏–∫ ‚Üí —Ç—ã—Å—è—á—É —Ä–∞–∑;

–∏—Å—Ç–æ—Ä–∏–∏ –∏–∑–º–µ–Ω—ë–Ω–Ω—ã—Ö —Å—É–¥–µ–± ‚Üí –∫–ª–∞—Å—Å–∏–∫–∞.

–ù–æ –≤ —Ç–∞–∫–æ–π —Å–≤—è–∑–∫–µ ‚Äî —ç—Ç–æ —Ä–µ–¥–∫–æ—Å—Ç—å. –¢—ã –ø–æ–ø–∞–ª –≤ —Ç–æ—á–∫—É, –≥–¥–µ –∏–¥–µ–∏ –Ω–µ –∫–æ–ø–∏—Ä—É—é—Ç –¥—Ä—É–≥ –¥—Ä—É–≥–∞, –∞ —É—Å–∏–ª–∏–≤–∞—é—Ç—Å—è.

–ù–∞ —á—Ç–æ —ç—Ç–æ –ø–æ—Ö–æ–∂–µ (–∏ —á–µ–º –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è)
1. –ü–∞—Ç—Ä–∏–∫ –ó—é—Å–∫–∏–Ω–¥, ¬´–ü–∞—Ä—Ñ—é–º–µ—Ä¬ª

–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–µ–∏–∑–±–µ–∂–Ω–æ ‚Äî –∏ —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ.

–ù–æ:
–ì—Ä–µ–Ω—É–π ‚Äî —ç—Ç–æ —Ä–æ–º–∞–Ω –æ –≤–ª–∞—Å—Ç–∏ –Ω–∞–¥ –ª—é–¥—å–º–∏ —á–µ—Ä–µ–∑ –∑–∞–ø–∞—Ö.
–¢–≤–æ–π –≥–µ—Ä–æ–π ‚Äî –æ —Å–ª—É–∂–µ–Ω–∏–∏ –±–µ–∑ –æ–±–ª–∞–¥–∞–Ω–∏—è.

–ì—Ä–µ–Ω—É–π –±–µ—Ä—ë—Ç.
–¢–≤–æ–π –≥–µ—Ä–æ–π –æ—Ç–¥–∞—ë—Ç ‚Äî –∏ –∫–∞–∂–¥—ã–π —Ä–∞–∑ —Ç–µ—Ä—è–µ—Ç —á–∞—Å—Ç—å —Å–µ–±—è.

–≠—Ç–æ –ø—Ä–∏–Ω—Ü–∏–ø–∏–∞–ª—å–Ω–æ –¥—Ä—É–≥–∞—è —ç—Ç–∏–∫–∞. –û—á–µ–Ω—å –≤–∞–∂–Ω–æ —ç—Ç–æ –ø–æ–¥—á–µ—Ä–∫–Ω—É—Ç—å –Ω–µ –¥–µ–∫–ª–∞—Ä–∞—Ü–∏–µ–π, –∞ –ø–æ—Å—Ç—É–ø–∫–∞–º–∏.

2. –î–∞–≤–∏–¥ –§–æ–Ω–∫–∏–Ω–æ—Å / –§—Ä–µ–¥–µ—Ä–∏–∫ –ë–µ–≥–±–µ–¥–µ—Ä (—Å–≤–µ—Ç–ª–∞—è –ª–∏–Ω–∏—è)

–û—Ç –Ω–∏—Ö ‚Äî –ª–µ–≥–∫–æ—Å—Ç—å, —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ—Å—Ç—å, –≤–Ω–∏–º–∞–Ω–∏–µ –∫ —á–∞—Å—Ç–Ω–æ–π –∂–∏–∑–Ω–∏, –Ω–æ –±–µ–∑ –∏—Ö –Ω–∞—Ä—Ü–∏—Å—Å–∏–∑–º–∞.

3. –ú–∏—Ç—á –≠–ª–±–æ–º (¬´–ü—è—Ç—å –≤—Å—Ç—Ä–µ—á –Ω–∞ –Ω–µ–±–µ—Å–∞—Ö¬ª)

–°—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ –±–ª–∏–∑–∫–æ:
—á–µ—Ä–µ–¥–∞ –∏—Å—Ç–æ—Ä–∏–π ‚Üí –µ–¥–∏–Ω—ã–π —Å–º—ã—Å–ª ‚Üí –∑–∞–≤–µ—â–∞–Ω–∏–µ.

–ù–æ —É —Ç–µ–±—è –≥–ª—É–±–∂–µ —Å–µ–Ω—Å–æ—Ä–∏–∫–∞ –∏ –º–µ–Ω—å—à–µ –º–æ—Ä–∞–ª–∏–∑–∞—Ç–æ—Ä—Å—Ç–≤–∞.

4. –ú—É—Ä–∞–∫–∞–º–∏ (—Ä–∞–Ω–Ω–∏–π)

–ù–µ –ø–æ —Å—é–∂–µ—Ç—É, –∞ –ø–æ –æ—â—É—â–µ–Ω–∏—é:

—Ç–∏—Ö–æ–µ —á—É–¥–æ,

–¥–∞—Ä –∫–∞–∫ –±—Ä–µ–º—è,

–æ–¥–∏–Ω–æ—á–µ—Å—Ç–≤–æ —á–µ–ª–æ–≤–µ–∫–∞, –∫–æ—Ç–æ—Ä—ã–π –∑–Ω–∞–µ—Ç –±–æ–ª—å—à–µ –¥—Ä—É–≥–∏—Ö.

–ß—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ —Å–∏–ª—å–Ω–æ (–∏ —ç—Ç–æ —Å—Ç–æ–∏—Ç –±–µ—Ä–µ—á—å)

–§–ª–∞–Ω–∫–µ—Ä—ã –∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –≤—Å–ø—ã—à–∫–∏
–ö–∞–∂–¥—ã–π –∞—Ä–æ–º–∞—Ç ‚Äî –ø–æ—Å–ª–µ–¥–Ω–∏–π. –≠—Ç–æ –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ —Ç–æ—á–Ω–∞—è –º–µ—Ç–∞—Ñ–æ—Ä–∞ –ø–∞–º—è—Ç–∏, –∏—Å–∫—É—Å—Å—Ç–≤–∞ –∏ —Å—Ç–∞—Ä–µ–Ω–∏—è. –¢—É—Ç –ø–æ—á—Ç–∏ –≥–æ—Ç–æ–≤–∞—è —Ñ–∏–ª–æ—Å–æ—Ñ–∏—è:

–º—ã —á—É–≤—Å—Ç–≤—É–µ–º –ø–æ-–Ω–∞—Å—Ç–æ—è—â–µ–º—É —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ –∑–Ω–∞–µ–º, —á—Ç–æ —ç—Ç–æ ‚Äî –≤ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑.

–û–Ω –Ω–µ –º–µ–Ω—è–µ—Ç –º–∏—Ä –≥–ª–æ–±–∞–ª—å–Ω–æ
–û–Ω –Ω–µ —Å–ø–∞—Å–∞–µ—Ç —á–µ–ª–æ–≤–µ—á–µ—Å—Ç–≤–æ.
–û–Ω —Å–ø–∞—Å–∞–µ—Ç –æ–¥–Ω–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞ –∑–∞ —Ä–∞–∑.
–≠—Ç–æ –¥–µ–ª–∞–µ—Ç –∫–Ω–∏–≥—É —á–µ–ª–æ–≤–µ—á–Ω–æ–π –∏ –ø—Ä–∞–≤–¥–∏–≤–æ–π.

–ó–∞–≤–µ—â–∞–Ω–∏–µ –∫–∞–∫ –ø–µ—Ä–µ–¥–∞—á–∞ –¥–∞—Ä–∞
–û—á–µ–Ω—å —Ö–æ—Ä–æ—à–∞—è —Ä–∞–º–∫–∞. –ù–µ —Ñ–∏–Ω–∞–ª, –∞ —ç—Å—Ç–∞—Ñ–µ—Ç–∞. –ö–Ω–∏–≥–∞ –Ω–µ ¬´–∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è¬ª, –∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç –¥—ã—à–∞—Ç—å –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —Ç–µ–∫—Å—Ç–∞.

–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ —Ä–∏—Å–∫–∏ (–∏ –∫–∞–∫ –∏—Ö –æ–±–æ–π—Ç–∏)

–°–∫–∞–∂—É —á–µ—Å—Ç–Ω–æ, –∫–∞–∫ —Ä–µ–¥–∞–∫—Ç–æ—Ä:

–û–ø–∞—Å–Ω–æ—Å—Ç—å –æ–¥–Ω–æ–æ–±—Ä–∞–∑–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
–ï—Å–ª–∏ –≤—Å–µ –∏—Å—Ç–æ—Ä–∏–∏ –±—É–¥—É—Ç —Å–ª–∏—à–∫–æ–º –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏, —á–∏—Ç–∞—Ç–µ–ª—å —É—Å—Ç–∞–Ω–µ—Ç.
–†–µ—à–µ–Ω–∏–µ:
–∏–Ω–æ–≥–¥–∞ –ª–æ–º–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É,
–∏–Ω–æ–≥–¥–∞ –ø—Ä–æ–ø—É—Å–∫–∞—Ç—å —ç—Ç–∞–ø,
–∏–Ω–æ–≥–¥–∞ –¥–∞–≤–∞—Ç—å ¬´–Ω–µ—É–¥–∞—á–Ω—ã–π —Ñ–ª–∞–Ω–∫–µ—Ä¬ª.

–°–ª–∏—à–∫–æ–º –∏–¥–µ–∞–ª—å–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å—É–¥–µ–±
–õ—É—á—à–µ, –µ—Å–ª–∏ –Ω–µ –≤—Å–µ–≥–¥–∞ ¬´–∫ –ª—É—á—à–µ–º—É¬ª –≤ –±—ã—Ç–æ–≤–æ–º —Å–º—ã—Å–ª–µ.
–ò–Ω–æ–≥–¥–∞ ‚Äî –∫ —á–µ—Å—Ç–Ω–æ—Å—Ç–∏, —Ä–∞—Å—Å—Ç–∞–≤–∞–Ω–∏—é, —É—Ç—Ä–∞—Ç–µ –∏–ª–ª—é–∑–∏–π. –≠—Ç–æ —É—Å–∏–ª–∏—Ç –¥–æ–≤–µ—Ä–∏–µ.

–ò–∑–ª–∏—à–Ω—è—è –ø–∞—Ä—Ñ—é–º–µ—Ä–Ω–∞—è –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è
–ü–∏—Ä–∞–º–∏–¥–∞ –∞—Ä–æ–º–∞—Ç–∞ ‚Äî –∫–ª–∞—Å—Å–Ω–æ, –Ω–æ –≤–∞–∂–Ω–æ, —á—Ç–æ–±—ã –æ–Ω–∞ —Ä–∞–±–æ—Ç–∞–ª–∞ –∫–∞–∫ –ø–æ—ç–∑–∏—è, –∞ –Ω–µ –∫–∞–∫ –∫–∞—Ç–∞–ª–æ–≥.

–ò—Ç–æ–≥–æ–≤–æ–µ –º–Ω–µ–Ω–∏–µ

–≠—Ç–æ:

–æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è –∏–¥–µ—è —Å –≤—ã—Å–æ–∫–æ–π –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–Ω–æ–π –ø–æ—Ç–µ–Ω—Ü–∏–µ–π;

–∫–Ω–∏–≥–∞, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç —Å—Ç–∞—Ç—å ¬´—Ç–∏—Ö–∏–º –∫—É–ª—å—Ç–æ–º¬ª;

—Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥—É—Ç —Å–æ–≤–µ—Ç–æ–≤–∞—Ç—å –Ω–µ –≤—Å–µ–º, –∞ –Ω—É–∂–Ω—ã–º –ª—é–¥—è–º ‚Äî –∞ —ç—Ç–æ —Å–∞–º—ã–π —Ü–µ–Ω–Ω—ã–π –ø—É—Ç—å.

–ü—Ä–∏ —Ö–æ—Ä–æ—à–µ–º —è–∑—ã–∫–µ –∏ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–µ —Ñ–æ—Ä–º—ã —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–º–µ–Ω–Ω–æ —Ç–∞ –∫–Ω–∏–≥–∞, –æ –∫–æ—Ç–æ—Ä–æ–π –≥–æ–≤–æ—Ä—è—Ç:

¬´–Ø –Ω–µ –∑–Ω–∞—é, –ø–æ—á–µ–º—É, –Ω–æ –ø–æ—Å–ª–µ –Ω–µ—ë —Ö–æ—á–µ—Ç—Å—è –∂–∏—Ç—å —á—É—Ç—å –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–µ–µ¬ª.

–ï—Å–ª–∏ —Ä–∞–∑–≤–∏–≤–∞—Ç—å –¥–∞–ª—å—à–µ, —Å–ª–µ–¥—É—é—â–∏–π –ª–æ–≥–∏—á–Ω—ã–π —à–∞–≥ ‚Äî —Ä–∞–∑–≥–æ–≤–æ—Ä –Ω–µ –æ —Ä—ã–Ω–∫–µ, –∞ –æ —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ —è–∑—ã–∫–∞ –≥–µ—Ä–æ—è: –Ω–∞—Å–∫–æ–ª—å–∫–æ –æ–Ω —É—Å—Ç–∞–ª—ã–π, –Ω–∞—Å–∫–æ–ª—å–∫–æ –∏—Ä–æ–Ω–∏—á–Ω—ã–π, –Ω–∞—Å–∫–æ–ª—å–∫–æ –æ—Ç—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–π. –≠—Ç–æ –±—É–¥–µ—Ç —Ä–µ—à–∞—Ç—å –≤—Å—ë.<script>
/* ===========================
   –ü–æ–∏—Å–∫ —Å—É—â–Ω–æ—Å—Ç–µ–π
=========================== */
function findBlock(blockId){
  return state.blocks.find(b=>b.id===blockId) || null;
}
function findExercise(exId){
  for(const b of state.blocks){
    const e = b.exercises.find(x=>x.id===exId);
    if(e) return {block:b, ex:e};
  }
  return null;
}
function findWeight(exId, wId){
  const fe = findExercise(exId);
  if(!fe) return null;
  const w = fe.ex.weights.find(x=>x.id===wId);
  if(!w) return null;
  return {block:fe.block, ex:fe.ex, w};
}
function allExercises(){
  const res = [];
  for(const b of state.blocks){
    for(const e of b.exercises) res.push({block:b, ex:e});
  }
  return res;
}

/* ===========================
   Entries helpers
=========================== */
function getCellEntry(workoutId, exId, wId){
  return (((state.entries[workoutId]||{})[exId]||{})[wId]) || null;
}
function ensureEntryContainer(workoutId, exId){
  state.entries[workoutId] ||= {};
  state.entries[workoutId][exId] ||= {};
  return state.entries[workoutId][exId];
}
function setCellEntry(workoutId, exId, wId, entry){
  const exCont = ensureEntryContainer(workoutId, exId);
  if(entry==null){
    delete exCont[wId];
  }else{
    exCont[wId] = entry;
  }
}

/* ===========================
   –ü–æ–≤—Ç–æ—Ä—ã: —Å—É–º–º–∞—Ä–Ω—ã–µ + —Ä–∞–∑–±–æ—Ä
=========================== */
function sumNumericPartsFromSetVal(setVal, steps){
  const meta = repsMeta(setVal, steps);
  if(!meta) return 0;
  return meta.parts.reduce((a,b)=>a+(b||0),0);
}
function lastPartFromSetVal(setVal, steps){
  const meta = repsMeta(setVal, steps);
  return meta ? meta.last : null;
}
function normalizeSetDisplay(setVal, steps){
  const meta = repsMeta(setVal, steps);
  return meta ? meta.str : "";
}
function firstPartFromSetVal(setVal, steps){
  const meta = repsMeta(setVal, steps);
  if(!meta) return null;
  return meta.parts[0] ?? null;
}

/* —Å—É–º–º–∞ reps –≤ —è—á–µ–π–∫–µ (–¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏/–æ–±—ä—ë–º–∞) */
function entryTotalReps(entry, splitLR, side, steps){
  if(!entry) return 0;
  const getSets = ()=>{
    if(!splitLR) return (entry.sets||[]);
    const part = entry[side] || {sets:[]};
    return (part.sets||[]);
  };
  const sets = getSets();
  return (sets||[]).reduce((a,sv)=>a + sumNumericPartsFromSetVal(sv, steps), 0);
}
function entrySetsCount(entry, splitLR, side){
  if(!entry) return 0;
  const sets = (!splitLR) ? (entry.sets||[]) : ((entry[side]?.sets)||[]);
  return (sets||[]).filter(v => String(v ?? "").trim().length>0).length;
}
function entryHasData(entry, splitLR, side){
  if(!entry) return false;
  const sets = (!splitLR) ? (entry.sets||[]) : ((entry[side]?.sets)||[]);
  return (sets||[]).some(v => String(v ?? "").trim().length>0);
}
function entryInjury(entry, splitLR, side){
  if(!entry) return false;
  if(!splitLR) return !!entry.injury;
  return !!(entry[side] && entry[side].injury);
}

/* ===========================
   –•—Ä–æ–Ω–æ–ª–æ–≥–∏—è + –∏–Ω–¥–µ–∫—Å—ã
=========================== */
function buildChronoIndex(){
  const workouts = sortWorkoutsAsc(state.workouts);
  const wOrder = workouts.map(w=>w.id);

  const history = {};
  for(const wid of wOrder){
    const wEntries = state.entries[wid] || {};
    for(const exId of Object.keys(wEntries)){
      history[exId] ||= {};
      const weightsMap = wEntries[exId] || {};
      for(const wId of Object.keys(weightsMap)){
        const fe = findExercise(exId);
        if(!fe) continue;

        const entry = weightsMap[wId];
        history[exId][wId] ||= { N: [], L: [], R: [] };

        const collectSide = (sideKey)=>{
          const fw = findWeight(exId, wId);
          const steps = weightStepsFromLabel(fw?.w?.label);
          const split = fe.ex.splitLR;
          const has = entryHasData(entry, split, sideKey==="N"?null:sideKey);
          const injury = entryInjury(entry, split, sideKey==="N"?null:sideKey);
          const total = entryTotalReps(entry, split, sideKey==="N"?null:sideKey, steps);

          const bestLastByPrefix = {};
          if(has && steps>1){
            const sets = (!split) ? (entry.sets||[]) : ((entry[sideKey]?.sets)||[]);
            for(const sv of sets){
              const meta = repsMeta(sv, steps);
              if(!meta) continue;
              const key = meta.prefixKey;
              bestLastByPrefix[key] = Math.max(bestLastByPrefix[key] ?? -Infinity, meta.last);
            }
          }
          return {workoutId: wid, hasData: has, total, bestLastByPrefix, injury, steps};
        };

        if(!fe.ex.splitLR){
          history[exId][wId].N.push(collectSide("N"));
        }else{
          history[exId][wId].L.push(collectSide("L"));
          history[exId][wId].R.push(collectSide("R"));
        }
      }
    }
  }

  return {workouts, wOrder, history};
}

/* –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Ä–µ–∫–æ—Ä–¥—ã (–ª–µ—Å–µ–Ω–∫–∞: prefix -> maxLast; –æ–±—ã—á–Ω—ã–π: "" -> maxTotal) */
function prevBestLastMap(chrono, workoutId, exId, wId, sideKey, steps){
  const seq = ((chrono.history[exId]||{})[wId]||{})[sideKey] || [];
  const map = {};
  for(const it of seq){
    if(it.workoutId === workoutId) break;
    if(!it.hasData) continue;
    if(steps<=1){
      map[""] = Math.max(map[""] ?? -Infinity, it.total);
    }else{
      for(const [k,v] of Object.entries(it.bestLastByPrefix || {})){
        map[k] = Math.max(map[k] ?? -Infinity, v);
      }
    }
  }
  return map;
}

/* NEW: –¥–ª—è –ª–µ—Å–µ–Ω–æ–∫ ‚Äú–Ω–æ–≤—ã–π –≤–µ—Å‚Äù = –Ω–æ–≤—ã–π –ø–µ—Ä–≤—ã–π –ø–æ–≤—Ç–æ—Ä (–ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ) */
function prevFirstPartsSet(chrono, workoutId, exId, wId, sideKey, steps){
  const set = new Set();
  if(steps<=1) return set;
  const seq = ((chrono.history[exId]||{})[wId]||{})[sideKey] || [];
  for(const it of seq){
    if(it.workoutId === workoutId) break;
    if(!it.hasData) continue;

    const entry = getCellEntry(it.workoutId, exId, wId);
    if(!entry) continue;
    const fe = findExercise(exId);
    if(!fe) continue;
    const split = fe.ex.splitLR;
    const sets = (!split) ? (entry.sets||[]) : ((entry[sideKey]?.sets)||[]);
    for(const sv of (sets||[])){
      const fp = firstPartFromSetVal(sv, steps);
      if(fp!=null) set.add(fp);
    }
  }
  return set;
}

/* —Ç–µ–∫—É—â–∏–µ –ø–µ—Ä–≤—ã–µ –ø–æ–≤—Ç–æ—Ä—ã */
function currentFirstPartsSet(entry, splitLR, sideKey, steps){
  const set = new Set();
  if(!entry || steps<=1) return set;
  const sets = (!splitLR) ? (entry.sets||[]) : ((entry[sideKey]?.sets)||[]);
  for(const sv of (sets||[])){
    const fp = firstPartFromSetVal(sv, steps);
    if(fp!=null) set.add(fp);
  }
  return set;
}

/* —Ü–µ–ª—å –¥–ª—è –ø—É—Å—Ç–æ–π —è—á–µ–π–∫–∏ */
function goalForEmptyCell(chrono, workoutId, exId, wId, sideKey){
  const fw = findWeight(exId, wId);
  const steps = weightStepsFromLabel(fw?.w?.label);

  if(steps<=1){
    const seq = ((chrono.history[exId]||{})[wId]||{})[sideKey] || [];
    let maxPrev = -Infinity;
    let hasPrev = false;
    for(const it of seq){
      if(it.workoutId === workoutId) break;
      if(it.hasData){
        hasPrev = true;
        maxPrev = Math.max(maxPrev, it.total);
      }
    }
    if(!hasPrev) return null;
    return (maxPrev + 1);
  }

  const prevMap = prevBestLastMap(chrono, workoutId, exId, wId, sideKey, steps);
  const keys = Object.keys(prevMap);
  if(keys.length===0) return null;

  const variants = keys
    .sort()
    .map(k => `${k}-${(prevMap[k] + 1)}`);

  return variants.join(" –∏–ª–∏ ");
}

function currentBestLastMap(entry, splitLR, sideKey, steps){
  const map = {};
  if(!entry || steps<=1) return map;
  const sets = (!splitLR) ? (entry.sets||[]) : ((entry[sideKey]?.sets)||[]);
  for(const sv of sets){
    const meta = repsMeta(sv, steps);
    if(!meta) continue;
    map[meta.prefixKey] = Math.max(map[meta.prefixKey] ?? -Infinity, meta.last);
  }
  return map;
}

function computeCellStatus(chrono, workoutId, exId, wId, sideKey){
  const fe = findExercise(exId);
  if(!fe) return {border:null, gray:false, injury:false, isRecord:false, isNewWeight:false, isNewEx:false};

  const split = fe.ex.splitLR;
  const entry = getCellEntry(workoutId, exId, wId);

  const fw = findWeight(exId, wId);
  const steps = weightStepsFromLabel(fw?.w?.label);

  const has = entryHasData(entry, split, sideKey==="N"?null:sideKey);
  const injury = entryInjury(entry, split, sideKey==="N"?null:sideKey);

  const prevMap = prevBestLastMap(chrono, workoutId, exId, wId, sideKey, steps);
  const hadPrevDataForThisWeight = Object.keys(prevMap).length>0;

  // —Ä–µ–∫–æ—Ä–¥
  let isRecord = false;
  if(has){
    if(steps<=1){
      const total = entryTotalReps(entry, split, sideKey==="N"?null:sideKey, 1);
      const maxPrev = prevMap[""] ?? -Infinity;
      isRecord = hadPrevDataForThisWeight && (total > maxPrev);
    }else{
      const curMap = currentBestLastMap(entry, split, sideKey, steps);
      for(const [k, curLast] of Object.entries(curMap)){
        const prevLast = prevMap[k];
        if(prevLast != null && curLast > prevLast){
          isRecord = true;
          break;
        }
      }
    }
  }

  // (–≥) –Ω–æ–≤—ã–π –≤–µ—Å:
  // - –æ–±—ã—á–Ω—ã–π –≤–µ—Å: –∫–∞–∫ —Ä–∞–Ω—å—à–µ (–ø–µ—Ä–≤–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö)
  // - –ª–µ—Å–µ–Ω–∫–∞: –Ω–æ–≤—ã–π –ø–µ—Ä–≤—ã–π –ø–æ–≤—Ç–æ—Ä (–ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ) –¥–∞–∂–µ –µ—Å–ª–∏ –≤–µ—Å –≤—Å—Ç—Ä–µ—á–∞–ª—Å—è
  let isNewWeight = false;
  if(has){
    if(steps<=1){
      isNewWeight = !hadPrevDataForThisWeight;
    }else{
      const prevFirsts = prevFirstPartsSet(chrono, workoutId, exId, wId, sideKey, steps);
      const curFirsts = currentFirstPartsSet(entry, split, sideKey, steps);
      let anyNewFirst = false;
      for(const fp of curFirsts){
        if(!prevFirsts.has(fp)){ anyNewFirst = true; break; }
      }
      isNewWeight = (!hadPrevDataForThisWeight) || anyNewFirst;
    }
  }

  // –Ω–æ–≤–æ–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ
  let isNewEx = false;
  if(has){
    let anyBefore = false;
    const wOrder = chrono.wOrder;
    for(const wid of wOrder){
      if(wid === workoutId) break;
      const wEntries = state.entries[wid] || {};
      const exMap = wEntries[exId] || {};
      if(!exMap) continue;
      for(const wKey of Object.keys(exMap)){
        const ent = exMap[wKey];
        if(!split){
          if(entryHasData(ent,false)){ anyBefore = true; break; }
        }else{
          if(entryHasData(ent,true,"L") || entryHasData(ent,true,"R")){ anyBefore = true; break; }
        }
      }
      if(anyBefore) break;
    }
    isNewEx = !anyBefore;
  }

  // —Å–µ—Ä—ã–π —Ñ–æ–Ω
  const gray = has && hadPrevDataForThisWeight && !isRecord;

  // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –æ–±–≤–æ–¥–∫–∏: —Ä–µ–∫–æ—Ä–¥ > –Ω–æ–≤—ã–π –≤–µ—Å > –Ω–æ–≤–æ–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ
  let border = null;
  if(isRecord) border = "gold";
  else if(isNewWeight) border = "green";
  else if(isNewEx) border = "yellow";

  return {border, gray, injury, isRecord, isNewWeight, isNewEx};
}

/* ===========================
   –†–µ–Ω–¥–µ—Ä —Ç–∞–±–ª–∏—Ü—ã
=========================== */
let chronoCache = null;

function renderTable(){
  state.workouts = sortWorkoutsAsc(state.workouts);
  chronoCache = buildChronoIndex();

  const workouts = sortWorkoutsDesc(chronoCache.workouts);

  let html = `<table><thead><tr>`;
  html += `<th class="stickyLeft corner"> </th>`;
  for(const w of workouts){
    html += `<th data-workout-head="${w.id}">
      <div class="dateHead">
        <span class="d">${w.date}</span>
        <button class="trash" data-del-workout="${w.id}" title="–£–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É">üóëÔ∏è</button>
      </div>
    </th>`;
  }
  html += `</tr></thead><tbody>`;

  for(const block of state.blocks){
    html += `<tr class="blockRow" data-block="${block.id}">
      <td class="stickyLeft">
        <div class="leftCell">
          <button class="tinyIcon" data-toggle-block="${block.id}" title="–°–≤–µ—Ä–Ω—É—Ç—å/—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å">${block.collapsed ? "‚ñ∂" : "‚ñº"}</button>
          <div class="leftText">${escapeHtml(block.name)}</div>
        </div>
      </td>`;
    for(let i=0;i<workouts.length;i++) html += `<td></td>`;
    html += `</tr>`;

    if(block.collapsed) continue;

    for(const ex of block.exercises){
      if(ex.archived) continue;

      html += `<tr class="exRow" data-ex="${ex.id}">
        <td class="stickyLeft">
          <div class="leftCell">
            <div class="leftText">${escapeHtml(ex.name)}</div>
            ${ex.splitLR ? `<span class="pill" title="Split L/R">L/R</span>` : ``}
          </div>
        </td>`;
      for(let i=0;i<workouts.length;i++) html += `<td></td>`;
      html += `</tr>`;

      ex.weights.sort((a,b)=> weightMaxNumber(a.label)-weightMaxNumber(b.label));

      for(const w of ex.weights){
        if(w.hidden) continue;

        if(!ex.splitLR){
          html += renderWeightRow(workouts, block, ex, w, "N");
        }else{
          html += renderWeightRow(workouts, block, ex, w, "L");
          html += renderWeightRow(workouts, block, ex, w, "R");
        }
      }
    }
  }

  html += `</tbody></table>`;
  tableWrap.innerHTML = html;

  wireTableEvents();

  if(!renderTable._didAutoScroll){
    renderTable._didAutoScroll = true;
    setTimeout(()=>{ tableWrap.scrollLeft = 0; }, 0);
  }
}

function renderWeightRow(workouts, block, ex, w, side){
  const sideTag = side==="N" ? "" : `<span class="sideTag">${side}</span>`;
  const label = `${escapeHtml(w.label)}`;
  const steps = weightStepsFromLabel(w.label);

  const newestWorkoutId = chronoCache?.workouts?.length
    ? chronoCache.workouts[chronoCache.workouts.length - 1].id
    : null;

  let row = `<tr class="wRow" data-ex="${ex.id}" data-weight="${w.id}" data-side="${side}">
    <td class="stickyLeft">
      <div class="leftCell">
        ${sideTag}
        <div class="leftText">${label}</div>
        <button class="tinyIcon" data-toggle-weight="${ex.id}:${w.id}" title="–°–∫—Ä—ã—Ç—å/–ø–æ–∫–∞–∑–∞—Ç—å –≤–µ—Å">üëÅÔ∏è</button>
      </div>
    </td>`;

  for(const wo of workouts){
    const entry = getCellEntry(wo.id, ex.id, w.id);
    const split = ex.splitLR;
    const has = entryHasData(entry, split, side==="N"?null:side);

    const status = computeCellStatus(chronoCache, wo.id, ex.id, w.id, side);

    const goal = (!has && newestWorkoutId && wo.id === newestWorkoutId)
      ? goalForEmptyCell(chronoCache, wo.id, ex.id, w.id, side)
      : null;

    const setsArr = has
      ? (split ? (entry[side].sets||[]) : (entry.sets||[]))
      : [];

    // (–≤) –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤ —è—á–µ–π–∫–µ: –ù–ï —Å—É–º–º–∞, –∞ —Ç–æ–ª—å–∫–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ —Ç–∏–ø–∞ "12+10"
    const setsText = has
      ? setsArr.map(v => normalizeSetDisplay(v, steps)).filter(Boolean).join("+")
      : "";

    const valText = has
      ? setsText
      : (goal!=null ? `–Ω–∞–¥–æ ${goal}` : "");

    let cls = "cell";
    if(!has) cls += " empty";
    if(status.gray) cls += " gray";
    if(status.injury) cls += " injury";
    if(status.border==="gold") cls += " border-gold";
    if(status.border==="green") cls += " border-green";
    if(status.border==="yellow") cls += " border-yellow";

    row += `<td class="${cls}"
      data-cell="${wo.id}|${ex.id}|${w.id}|${side}">
        <div class="val">${escapeHtml(valText)}</div>
        <div class="sub"></div>
      </td>`;
  }

  row += `</tr>`;
  return row;
}

function wireTableEvents(){
  $$("[data-toggle-block]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const id = btn.getAttribute("data-toggle-block");
      const b = findBlock(id);
      if(!b) return;
      b.collapsed = !b.collapsed;
      saveState();
      renderAll();
    });
  });

  $$("[data-toggle-weight]").forEach(btn=>{
    btn.addEventListener("click", (e)=>{
      e.stopPropagation();
      const [exId, wId] = btn.getAttribute("data-toggle-weight").split(":");
      const fw = findWeight(exId, wId);
      if(!fw) return;
      fw.w.hidden = !fw.w.hidden;
      saveState();
      renderAll();
      if(drawer.classList.contains("show")) refreshWeightsList();
    });
  });

  $$("[data-del-workout]").forEach(btn=>{
    btn.addEventListener("click", (e)=>{
      e.stopPropagation();
      const wid = btn.getAttribute("data-del-workout");
      const w = state.workouts.find(x=>x.id===wid);
      if(!w) return;
      if(confirm(`–£–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É ${w.date}?`)){
        state.workouts = state.workouts.filter(x=>x.id!==wid);
        delete state.entries[wid];
        saveState();
        renderAll();
      }
    });
  });

  $$(".cell[data-cell]").forEach(td=>{
    td.addEventListener("click", ()=>{
      openCellEditor(td.getAttribute("data-cell"));
    });
  });

  $$("th[data-workout-head]").forEach(th=>{
    const wid = th.getAttribute("data-workout-head");
    let timer = null;
    let moved = false;

    const start = ()=>{
      moved = false;
      timer = setTimeout(()=>{
        timer = null;
        openWorkoutStats(wid);
      }, 700);
    };
    const cancel = ()=>{
      if(timer){ clearTimeout(timer); timer = null; }
    };

    th.addEventListener("touchstart", start, {passive:true});
    th.addEventListener("touchmove", ()=>{ moved=true; cancel(); }, {passive:true});
    th.addEventListener("touchend", ()=>{ if(!moved) cancel(); }, {passive:true});
    th.addEventListener("touchcancel", cancel, {passive:true});

    th.addEventListener("mousedown", start);
    th.addEventListener("mouseup", cancel);
    th.addEventListener("mouseleave", cancel);

    th.addEventListener("dblclick", ()=>openWorkoutStats(wid));
  });
}

/* ===========================
   –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏
=========================== */
$("#btnAddWorkout").addEventListener("click", ()=>{
  const s = prompt("–î–∞—Ç–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ (DD.MM.YYYY):", fmtDate(new Date()));
  if(s==null) return;
  const d = parseDDMMYYYY(s.trim());
  if(!d){
    alert("–ù–µ–≤–µ—Ä–Ω–∞—è –¥–∞—Ç–∞. –§–æ—Ä–º–∞—Ç: DD.MM.YYYY");
    return;
  }
  const date = fmtDate(d);
  state.workouts.push({id: nowId(), date});
  state.workouts = sortWorkoutsAsc(state.workouts);
  saveState();
  renderAll();
});

/* ===========================
   –†–µ–¥–∞–∫—Ç–æ—Ä —è—á–µ–π–∫–∏
=========================== */
let cellCtx = null;
function openCellEditor(cellKey){
  const [workoutId, exId, wId, side] = cellKey.split("|");
  const fe = findExercise(exId);
  const fw = findWeight(exId, wId);
  const wo = state.workouts.find(w=>w.id===workoutId);
  if(!fe || !fw || !wo) return;

  const ex = fe.ex;
  const split = ex.splitLR;
  const steps = weightStepsFromLabel(fw.w.label);

  const entry = getCellEntry(workoutId, exId, wId) || (split ? {L:{sets:[],injury:false},R:{sets:[],injury:false}} : {sets:[],injury:false});
  const sideName = side==="N" ? "" : ` ‚Ä¢ ${side}`;

  cellCtx = {workoutId, exId, wId, side, steps};

  $("#cellTitle").textContent = `${ex.name} ‚Ä¢ ${fw.w.label}${sideName}`;
  $("#cellSubtitle").textContent = `${wo.date} ‚Ä¢ –≤–≤–æ–¥: –ø–æ–≤—Ç–æ—Ä—ã –ø–æ —Å–µ—Ç–∞–º`;

  const sets = split ? (entry[side].sets||[]) : (entry.sets||[]);
  renderSetsEditor(sets, steps);

  const inj = split ? !!entry[side].injury : !!entry.injury;
  $("#btnToggleInjury").textContent = inj ? "–í–∫–ª" : "–í—ã–∫–ª";
  $("#btnToggleInjury").dataset.on = inj ? "1" : "0";

  cellModalOverlay.classList.add("show");
  cellModalOverlay.setAttribute("aria-hidden","false");
}
function closeCellEditor(){
  cellModalOverlay.classList.remove("show");
  cellModalOverlay.setAttribute("aria-hidden","true");
  cellCtx = null;
}
$("#btnCloseCellModal").addEventListener("click", closeCellEditor);
$("#btnCancelCell").addEventListener("click", closeCellEditor);
cellModalOverlay.addEventListener("click", (e)=>{
  if(e.target === cellModalOverlay) closeCellEditor();
});

function renderSetsEditor(sets, steps){
  const wrap = $("#setsWrap");
  if(!sets || sets.length===0) sets = [""];

  const isLadder = steps>1;

  const ph = isLadder ? `–Ω–∞–ø—Ä–∏–º–µ—Ä: ${Array.from({length:steps}).map((_,i)=> i===0?"15":"7").join("-")}` : "–ø–æ–≤—Ç–æ—Ä—ã";
  const type = isLadder ? "text" : "number";
  const inputmode = isLadder ? "text" : "numeric";
  const pattern = isLadder ? "[0-9\\-]*" : null;

  wrap.innerHTML = sets.map((v, idx)=>`
    <div class="setRow" data-set-row="${idx}">
      <input
        type="${type}"
        inputmode="${inputmode}"
        ${pattern ? `pattern="${pattern}"` : ``}
        ${!isLadder ? `min="0"` : ``}
        placeholder="${escapeAttr(ph)}"
        value="${escapeAttr(isLadder ? String(v??"") : (v??""))}" />
      <button class="btn icon" data-del-set="${idx}" aria-label="–£–¥–∞–ª–∏—Ç—å —Å–µ—Ç">‚àí</button>
    </div>
  `).join("");

  $$("[data-del-set]", wrap).forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const i = +btn.getAttribute("data-del-set");
      const rows = $$('[data-set-row] input', wrap).map(inp=>inp.value);
      rows.splice(i,1);
      renderSetsEditor(rows, steps);
    });
  });
}

$("#btnAddSet").addEventListener("click", ()=>{
  const wrap = $("#setsWrap");
  const steps = cellCtx?.steps ?? 1;
  const rows = $$('[data-set-row] input', wrap).map(inp=>inp.value);
  rows.push("");
  renderSetsEditor(rows, steps);
});
$("#btnClearSets").addEventListener("click", ()=>{
  const steps = cellCtx?.steps ?? 1;
  renderSetsEditor([""], steps);
});
$("#btnToggleInjury").addEventListener("click", ()=>{
  const btn = $("#btnToggleInjury");
  const on = btn.dataset.on === "1";
  btn.dataset.on = on ? "0" : "1";
  btn.textContent = on ? "–í—ã–∫–ª" : "–í–∫–ª";
});

$("#btnSaveCell").addEventListener("click", ()=>{
  if(!cellCtx) return;
  const {workoutId, exId, wId, side, steps} = cellCtx;
  const fe = findExercise(exId);
  if(!fe) return;
  const split = fe.ex.splitLR;

  const raw = $$('[data-set-row] input', $("#setsWrap")).map(inp=>inp.value);

  const parsed = raw
    .map(v => parseRepsValue(v, steps))
    .filter(v => v!=null);

  const injuryOn = ($("#btnToggleInjury").dataset.on === "1");

  let entry = getCellEntry(workoutId, exId, wId);
  if(!entry){
    entry = split
      ? {L:{sets:[],injury:false},R:{sets:[],injury:false}}
      : {sets:[],injury:false};
  }

  if(!split){
    entry.sets = parsed;
    entry.injury = injuryOn;
    if(entry.sets.length===0 && !entry.injury){
      setCellEntry(workoutId, exId, wId, null);
    }else{
      setCellEntry(workoutId, exId, wId, entry);
    }
  }else{
    entry[side] ||= {sets:[],injury:false};
    entry[side].sets = parsed;
    entry[side].injury = injuryOn;

    const emptyL = (entry.L?.sets||[]).length===0 && !entry.L?.injury;
    const emptyR = (entry.R?.sets||[]).length===0 && !entry.R?.injury;
    if(emptyL && emptyR){
      setCellEntry(workoutId, exId, wId, null);
    }else{
      setCellEntry(workoutId, exId, wId, entry);
    }
  }

  saveState();
  renderAll();
  closeCellEditor();
});

/* ===========================
   –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ (–º–æ–¥–∞–ª–∫–∞)
=========================== */
function effectiveSetUnitMultiplierForSteps(steps){
  // (–±) –ª–µ—Å–µ–Ω–∫–∏ —Å—á–∏—Ç–∞—é—Ç—Å—è –∫–∞–∫ 1.5 –ø–æ–¥—Ö–æ–¥–∞ –∑–∞ —Å–µ—Ç
  return (steps>1) ? 1.5 : 1;
}

// (–∞)+(–±) –ø–æ–¥—Å—á—ë—Ç –ø–æ–¥—Ö–æ–¥–æ–≤ –≤ –∑–∞—á—ë—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏:
// - split L/R: L+R = 1 –ø–æ–¥—Ö–æ–¥ (–±–µ—Ä—ë–º max(countL, countR))
// - –ª–µ—Å–µ–Ω–∫–∞: –∫–∞–∂–¥—ã–π —Ç–∞–∫–æ–π –ø–æ–¥—Ö–æ–¥ = 1.5
function workoutSetUnitsForCell(entry, splitLR, steps){
  if(!entry) return 0;
  const mult = effectiveSetUnitMultiplierForSteps(steps);
  if(!splitLR){
    const c = entrySetsCount(entry,false);
    return c * mult;
  }
  const cL = entrySetsCount(entry,true,"L");
  const cR = entrySetsCount(entry,true,"R");
  return Math.max(cL, cR) * mult;
}

function openWorkoutStats(workoutId){
  const wo = state.workouts.find(w=>w.id===workoutId);
  if(!wo) return;

  chronoCache = buildChronoIndex();

  let records = 0, newWeights = 0, newExercises = 0;
  const setsByBlock = {};
  for(const b of state.blocks){
    setsByBlock[b.name] = 0;
    for(const ex of b.exercises){
      if(ex.archived) continue;
      for(const w of ex.weights){
        if(w.hidden) continue;

        const steps = weightStepsFromLabel(w.label);
        const entry = getCellEntry(workoutId, ex.id, w.id);

        if(!ex.splitLR){
          const has = entryHasData(entry,false);
          if(!has) continue;

          const st = computeCellStatus(chronoCache, workoutId, ex.id, w.id, "N");
          if(st.isRecord) records++;
          if(st.isNewWeight) newWeights++;
          if(st.isNewEx) newExercises++;

          // (–∞)+(–±)
          setsByBlock[b.name] += workoutSetUnitsForCell(entry,false,steps);
        }else{
          // —Å—Ç–∞—Ç—É—Å—ã –æ—Å—Ç–∞—é—Ç—Å—è –∫–∞–∫ —Ä–∞–Ω—å—à–µ (–ø–æ —Å—Ç–æ—Ä–æ–Ω–∞–º), –∞ –ø–æ–¥—Ö–æ–¥—ã —Å—á–∏—Ç–∞–µ–º L+R –∫–∞–∫ 1
          for(const side of ["L","R"]){
            const has = entryHasData(entry,true,side);
            if(!has) continue;
            const st = computeCellStatus(chronoCache, workoutId, ex.id, w.id, side);
            if(st.isRecord) records++;
            if(st.isNewWeight) newWeights++;
            if(st.isNewEx) newExercises++;
          }
          // (–∞)+(–±)
          setsByBlock[b.name] += workoutSetUnitsForCell(entry,true,steps);
        }
      }
    }
  }

  const blockLines = Object.entries(setsByBlock)
    .filter(([,v])=>v>0)
    .map(([k,v])=>`<div class="kpi"><b>${formatOneDecimalIfNeeded(v)}</b><small>–ø–æ–¥—Ö–æ–¥–æ–≤ ‚Ä¢ ${escapeHtml(k)}</small></div>`)
    .join("");

  const html = `
    <div class="kpiRow" style="margin-bottom:10px">
      <div class="kpi"><b>${records}</b><small>—Ä–µ–∫–æ—Ä–¥–æ–≤</small></div>
      <div class="kpi"><b>${newWeights}</b><small>–Ω–æ–≤—ã—Ö –≤–µ—Å–æ–≤</small></div>
      <div class="kpi"><b>${newExercises}</b><small>–Ω–æ–≤—ã—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π</small></div>
    </div>

    <div style="margin:8px 0 10px; color:var(--muted); font-size:12px">
      –ü–æ–¥—Ö–æ–¥—ã: L+R —Å—á–∏—Ç–∞–µ—Ç—Å—è –∫–∞–∫ 1 –ø–æ–¥—Ö–æ–¥. –î–ª—è –ª–µ—Å–µ–Ω–æ–∫ (–Ω–∞–ø—Ä–∏–º–µ—Ä 60-50) –æ–¥–∏–Ω —Å–µ—Ç —Å—á–∏—Ç–∞–µ—Ç—Å—è –∫–∞–∫ 1.5 –ø–æ–¥—Ö–æ–¥–∞.
    </div>

    <div class="kpiRow">
      ${blockLines || `<div style="color:var(--muted)">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –≤ —ç—Ç–æ–π —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ.</div>`}
    </div>

    <hr style="border:none; border-top:1px solid var(--line); margin:12px 0">

    <div style="color:var(--muted); font-size:12px">
      –ü–æ–¥—Å–∫–∞–∑–∫–∞: long-press (~0.7s) –∏–ª–∏ double-tap –ø–æ –¥–∞—Ç–µ –≤ —Ç–∞–±–ª–∏—Ü–µ.
    </div>
  `;

  showInfo(`–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ ‚Ä¢ ${wo.date}`, html);
}

function formatOneDecimalIfNeeded(n){
  const r = Math.round(n*10)/10;
  return (Math.abs(r - Math.round(r)) < 1e-9) ? String(Math.round(r)) : r.toFixed(1);
}

/* ===========================
   –ú–µ–Ω—é: –¥–æ–±–∞–≤–∏—Ç—å/—É–ø—Ä–∞–≤–ª—è—Ç—å
=========================== */
function refreshMenuSelects(){
  $("#selBlockAddEx").innerHTML = state.blocks.map(b=>`<option value="${b.id}">${escapeHtml(b.name)}</option>`).join("");

  const exs = allExercises();
  const exOpt = exs.map(({block,ex})=>{
    const mark = ex.archived ? " (–∞—Ä—Ö–∏–≤)" : "";
    return `<option value="${ex.id}">${escapeHtml(block.name)} ‚Ä¢ ${escapeHtml(ex.name)}${mark}</option>`;
  }).join("");

  $("#selExAddWeight").innerHTML = exOpt;
  $("#selManageExercise").innerHTML = exOpt;

  refreshWeightsList();
  refreshSplitArchiveButtons();
}

function refreshSplitArchiveButtons(){
  const exId = $("#selManageExercise").value;
  const fe = findExercise(exId);
  if(!fe) return;
  $("#btnToggleSplit").textContent = fe.ex.splitLR ? "–í–∫–ª" : "–í—ã–∫–ª";
  $("#btnToggleArchive").textContent = fe.ex.archived ? "–í–∫–ª" : "–í—ã–∫–ª";
}

$("#selManageExercise").addEventListener("change", ()=>{
  refreshWeightsList();
  refreshSplitArchiveButtons();
});

function refreshWeightsList(){
  const exId = $("#selManageExercise").value;
  const fe = findExercise(exId);
  if(!fe){ $("#weightsList").innerHTML=""; return; }
  const ex = fe.ex;

  ex.weights.sort((a,b)=> weightMaxNumber(a.label)-weightMaxNumber(b.label));
  const items = ex.weights.map(w=>{
    const eye = w.hidden ? "üôà" : "üëÅÔ∏è";
    const txt = w.hidden ? `<span style="color:var(--muted)">${escapeHtml(w.label)} (—Å–∫—Ä—ã—Ç)</span>` : escapeHtml(w.label);
    return `
      <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 10px; border:1px solid var(--line); background:var(--bg); border-radius:14px; margin-bottom:6px">
        <div style="min-width:0; overflow:hidden; text-overflow:ellipsis">${txt}</div>
        <button class="btn icon" data-menu-toggle-weight="${w.id}" title="–°–∫—Ä—ã—Ç—å/–ø–æ–∫–∞–∑–∞—Ç—å">${eye}</button>
      </div>
    `;
  }).join("");

  $("#weightsList").innerHTML = items || `<div style="color:var(--muted); font-size:12px">–ù–µ—Ç –≤–µ—Å–æ–≤</div>`;

  $$("[data-menu-toggle-weight]", $("#weightsList")).forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const wId = btn.getAttribute("data-menu-toggle-weight");
      const fw = findWeight(exId, wId);
      if(!fw) return;
      fw.w.hidden = !fw.w.hidden;
      saveState();
      renderAll();
      refreshWeightsList();
    });
  });
}

$("#btnAddExercise").addEventListener("click", ()=>{
  const blockId = $("#selBlockAddEx").value;
  const name = $("#inExName").value.trim();
  if(!name){ alert("–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è."); return; }
  const b = findBlock(blockId);
  if(!b) return;

  b.exercises.push({
    id: nowId(),
    name,
    archived:false,
    splitLR:false,
    weights: []
  });
  $("#inExName").value = "";
  saveState();
  renderAll();
  refreshMenuSelects();
});

$("#btnAddWeight").addEventListener("click", ()=>{
  const exId = $("#selExAddWeight").value;
  const label = $("#inWeightLabel").value.trim();
  if(!label){ alert("–í–≤–µ–¥–∏ –≤–µ—Å."); return; }
  const fe = findExercise(exId);
  if(!fe) return;

  if(fe.ex.weights.some(w=>String(w.label).trim()===label)){
    alert("–¢–∞–∫–æ–π –≤–µ—Å —É–∂–µ –µ—Å—Ç—å —É —ç—Ç–æ–≥–æ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è.");
    return;
  }
  fe.ex.weights.push({id: nowId(), label, hidden:false});
  fe.ex.weights.sort((a,b)=> weightMaxNumber(a.label)-weightMaxNumber(b.label));
  $("#inWeightLabel").value = "";
  saveState();
  renderAll();
  refreshMenuSelects();
});

$("#btnToggleSplit").addEventListener("click", ()=>{
  const exId = $("#selManageExercise").value;
  const fe = findExercise(exId);
  if(!fe) return;

  fe.ex.splitLR = !fe.ex.splitLR;

  for(const wid of Object.keys(state.entries)){
    const wEntries = state.entries[wid] || {};
    const exMap = wEntries[exId] || null;
    if(!exMap) continue;

    for(const wId of Object.keys(exMap)){
      const ent = exMap[wId];
      if(fe.ex.splitLR){
        if(ent && !ent.L && !ent.R){
          exMap[wId] = {
            L:{sets: (ent.sets||[]), injury: !!ent.injury},
            R:{sets: [], injury:false}
          };
        }
      }else{
        if(ent && (ent.L || ent.R)){
          const pick = (ent.L && (ent.L.sets||[]).length>0) ? ent.L : (ent.R || {sets:[],injury:false});
          exMap[wId] = {sets: (pick.sets||[]), injury: !!pick.injury};
        }
      }
    }
  }

  saveState();
  renderAll();
  refreshMenuSelects();
});

$("#btnToggleArchive").addEventListener("click", ()=>{
  const exId = $("#selManageExercise").value;
  const fe = findExercise(exId);
  if(!fe) return;
  fe.ex.archived = !fe.ex.archived;
  saveState();
  renderAll();
  refreshMenuSelects();
});

$("#btnDeleteExercise").addEventListener("click", ()=>{
  const exId = $("#selManageExercise").value;
  const fe = findExercise(exId);
  if(!fe) return;
  const exName = fe.ex.name;
  if(!confirm(`–£–¥–∞–ª–∏—Ç—å —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ "${exName}" –Ω–∞–≤—Å–µ–≥–¥–∞? –≠—Ç–æ —É–¥–∞–ª–∏—Ç –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é.`)) return;

  fe.block.exercises = fe.block.exercises.filter(e=>e.id!==exId);
  for(const wid of Object.keys(state.entries)){
    if(state.entries[wid] && state.entries[wid][exId]){
      delete state.entries[wid][exId];
    }
  }
  saveState();
  renderAll();
  refreshMenuSelects();
});

/* ===========================
   –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
=========================== */
function refreshAnalyticsSelects(){
  anBlock.innerHTML = state.blocks.map(b=>`<option value="${b.id}">${escapeHtml(b.name)}</option>`).join("");
  const bId = anBlock.value || (state.blocks[0]?.id);
  if(bId) anBlock.value = bId;
  refreshAnalyticsExerciseList();
}
function refreshAnalyticsExerciseList(){
  const bId = anBlock.value;
  const b = findBlock(bId);
  if(!b){ anExercise.innerHTML=""; return; }
  const exs = b.exercises.filter(e=>!e.archived);
  anExercise.innerHTML = exs.map(e=>`<option value="${e.id}">${escapeHtml(e.name)}</option>`).join("");
  if(!anExercise.value && exs[0]) anExercise.value = exs[0].id;
}

anBlock.addEventListener("change", ()=>{ refreshAnalyticsExerciseList(); renderAnalytics(); });
anExercise.addEventListener("change", renderAnalytics);
anMetric.addEventListener("change", renderAnalytics);

function renderAnalytics(){
  refreshAnalyticsSelects();
  chronoCache = buildChronoIndex();

  const exId = anExercise.value;
  const fe = findExercise(exId);
  if(!fe){
    drawEmptyChart("–ù–µ—Ç —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è");
    kpiRow.innerHTML = "";
    insights.innerHTML = `<div class="muted">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö.</div>`;
    return;
  }
  const ex = fe.ex;
  const workouts = chronoCache.workouts;

  const points = [];
  const perWorkoutStats = [];
  for(const wo of workouts){
    let volume = 0;
    let reps = 0;
    let records = 0;
    let injuries = 0;

    for(const w of ex.weights){
      const steps = weightStepsFromLabel(w.label);
      const entry = getCellEntry(wo.id, exId, w.id);

      if(!ex.splitLR){
        if(entryHasData(entry,false)){
          const total = entryTotalReps(entry,false,null,steps);
          reps += total;
          const wt = weightMaxNumber(w.label);
          if(Number.isFinite(wt)) volume += (total * wt);

          const st = computeCellStatus(chronoCache, wo.id, exId, w.id, "N");
          if(st.isRecord) records++;
          if(entryInjury(entry,false)) injuries++;
        }
      }else{
        for(const side of ["L","R"]){
          if(entryHasData(entry,true,side)){
            const total = entryTotalReps(entry,true,side,steps);
            reps += total;
            const wt = weightMaxNumber(w.label);
            if(Number.isFinite(wt)) volume += (total * wt);

            const st = computeCellStatus(chronoCache, wo.id, exId, w.id, side);
            if(st.isRecord) records++;
            if(entryInjury(entry,true,side)) injuries++;
          }
        }
      }
    }

    perWorkoutStats.push({workoutId: wo.id, date: wo.date, records, injuries, volume, reps});
    points.push({x: wo.date, volume, reps, records, injuries});
  }

  const metric = anMetric.value;
  const yVals = points.map(p => p[metric] || 0);

  drawLineChart(points.map(p=>p.x), yVals, metricLabel(metric));

  const totalWorkouts = workouts.length;
  const totalRecords = perWorkoutStats.reduce((a,b)=>a+b.records,0);
  const totalInj = perWorkoutStats.reduce((a,b)=>a+b.injuries,0);

  const sumVol = perWorkoutStats.reduce((a,b)=>a+b.volume,0);
  const sumReps = perWorkoutStats.reduce((a,b)=>a+b.reps,0);

  kpiRow.innerHTML = `
    <div class="kpi"><b>${totalWorkouts}</b><small>—Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫ –≤ –∏—Å—Ç–æ—Ä–∏–∏</small></div>
    <div class="kpi"><b>${totalRecords}</b><small>—Ä–µ–∫–æ—Ä–¥–æ–≤ (–≤—Å–µ–≥–æ)</small></div>
    <div class="kpi"><b>${metric==="volume" ? Math.round(sumVol) : sumReps}</b><small>${metric==="volume" ? "—Å—É–º–º. –æ–±—ä—ë–º (‚âà)" : "—Å—É–º–º. –ø–æ–≤—Ç–æ—Ä—ã"}</small></div>
    <div class="kpi"><b>${totalInj}</b><small>—Ç—Ä–∞–≤–º (–º–µ—Ç–æ–∫)</small></div>
  `;

  const insightHtml = buildInsights(perWorkoutStats, ex);
  insights.innerHTML = insightHtml;
}

function metricLabel(m){
  if(m==="volume") return "–û–±—ä—ë–º";
  if(m==="reps") return "–ü–æ–≤—Ç–æ—Ä—ã";
  if(m==="records") return "–†–µ–∫–æ—Ä–¥—ã";
  if(m==="injuries") return "–¢—Ä–∞–≤–º—ã";
  return m;
}

function monthKey(dateStr){
  const d = parseDDMMYYYY(dateStr);
  if(!d) return "????-??";
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}`;
}
function buildInsights(perWorkoutStats, ex){
  const byMonth = {};
  for(const it of perWorkoutStats){
    const k = monthKey(it.date);
    byMonth[k] ||= {volume:0, reps:0, records:0, injuries:0, workouts:0};
    byMonth[k].volume += it.volume;
    byMonth[k].reps += it.reps;
    byMonth[k].records += it.records;
    byMonth[k].injuries += it.injuries;
    byMonth[k].workouts += 1;
  }
  const keys = Object.keys(byMonth).sort();
  const cur = keys[keys.length-1];
  const prev = keys[keys.length-2];

  let html = `<div><b>–ö–∞–∫ —Å—á–∏—Ç–∞—é %:</b> (–æ–±—ä—ë–º_—Ç–µ–∫—É—â–∏–π ‚àí –æ–±—ä—ë–º_–ø—Ä–æ—à–ª—ã–π) / max(–æ–±—ä—ë–º_–ø—Ä–æ—à–ª—ã–π, 1) √ó 100%</div>
              <div class="muted">–û–±—ä—ë–º = Œ£(—Å—É–º–º–∞ reps –≤ —è—á–µ–π–∫–µ √ó weight). –î–ª—è ‚Äú60-50‚Äù weight —Å—á–∏—Ç–∞–µ—Ç—Å—è –∫–∞–∫ max(...)=60. –î–ª—è reps ‚Äú15-7‚Äù —Å—É–º–º–∞ reps = 22 (–¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏).</div>`;

  if(cur && prev){
    const vCur = byMonth[cur].volume;
    const vPrev = byMonth[prev].volume;
    const pct = ((vCur - vPrev) / Math.max(vPrev, 1)) * 100;
    const sign = pct>=0 ? "+" : "";
    html += `<div style="margin-top:8px">
      <b>–ú–µ—Å—è—Ü –∫ –º–µ—Å—è—Ü—É:</b> ${sign}${pct.toFixed(1)}% –ø–æ –æ–±—ä—ë–º—É ( ${cur} vs ${prev} ).
      <div class="muted">–¢–µ–∫—É—â–∏–π: ${Math.round(vCur)}, –ø—Ä–æ—à–ª—ã–π: ${Math.round(vPrev)}.</div>
    </div>`;
  }else{
    html += `<div style="margin-top:8px" class="muted">–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–µ—Å—è—Ü–µ–≤ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è.</div>`;
  }

  const usedWeights = [];
  const injuryWeights = [];
  for(const wo of chronoCache.workouts){
    for(const w of ex.weights){
      const entry = getCellEntry(wo.id, ex.id, w.id);
      const wt = weightMaxNumber(w.label);
      if(!Number.isFinite(wt)) continue;

      const split = ex.splitLR;
      if(!split){
        if(entryHasData(entry,false)){
          usedWeights.push(wt);
          if(entryInjury(entry,false)) injuryWeights.push(wt);
        }
      }else{
        for(const side of ["L","R"]){
          if(entryHasData(entry,true,side)){
            usedWeights.push(wt);
            if(entryInjury(entry,true,side)) injuryWeights.push(wt);
          }
        }
      }
    }
  }
  if(usedWeights.length>=4 && injuryWeights.length>=2){
    usedWeights.sort((a,b)=>a-b);
    const med = usedWeights[Math.floor(usedWeights.length/2)];
    const highInj = injuryWeights.filter(w=>w>=med).length;
    const ratio = highInj / injuryWeights.length;
    if(ratio >= 0.6){
      html += `<div style="margin-top:10px">
        <b>–†–∏—Å–∫ —Ç—Ä–∞–≤–º:</b> –º–µ—Ç–∫–∏ —Ç—Ä–∞–≤–º —á–∞—â–µ –Ω–∞ –±–æ–ª–µ–µ —Ç—è–∂—ë–ª—ã—Ö –≤–µ—Å–∞—Ö (‚â• –º–µ–¥–∏–∞–Ω—ã ${med}).
        <div class="muted">–≠—Ç–æ –Ω–µ –º–µ–¥–∏—Ü–∏–Ω–∞. –ü—Ä–æ—Å—Ç–æ —Å–∏–≥–Ω–∞–ª: –ø—Ä–æ–≥—Ä–µ–≤, —Ç–µ—Ö–Ω–∏–∫–∞, –æ–±—ä—ë–º, –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ.</div>
      </div>`;
    }else{
      html += `<div style="margin-top:10px" class="muted">–¢—Ä–∞–≤–º—ã –Ω–µ –≤—ã–≥–ª—è–¥—è—Ç —Å–≤—è–∑–∞–Ω–Ω—ã–º–∏ –∏–º–µ–Ω–Ω–æ —Å –±–æ–ª—å—à–∏–º–∏ –≤–µ—Å–∞–º–∏ (–ø–æ —ç—Ç–æ–π —ç–≤—Ä–∏—Å—Ç–∏–∫–µ).</div>`;
    }
  }else{
    html += `<div style="margin-top:10px" class="muted">–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–µ—Ç–æ–∫ —Ç—Ä–∞–≤–º, —á—Ç–æ–±—ã –¥–µ–ª–∞—Ç—å –≤—ã–≤–æ–¥—ã.</div>`;
  }

  return html;
}

function drawEmptyChart(text){
  const ctx = chart.getContext("2d");
  const w = chart.width, h = chart.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--muted").trim() || "#64748b";
  ctx.font = "24px system-ui";
  ctx.textAlign = "center";
  ctx.fillText(text, w/2, h/2);
}
function drawLineChart(labels, values, title){
  const ctx = chart.getContext("2d");
  const W = chart.width, H = chart.height;

  ctx.clearRect(0,0,W,H);

  const padL = 50, padR = 16, padT = 24, padB = 46;
  const x0 = padL, y0 = padT, x1 = W-padR, y1 = H-padB;
  const innerW = x1-x0, innerH = y1-y0;

  const line = getVar("--line");
  const fg = getVar("--fg");
  const muted = getVar("--muted");
  ctx.strokeStyle = line;
  ctx.lineWidth = 1;

  const maxV = Math.max(...values, 0);
  const minV = Math.min(...values, 0);
  const span = Math.max(maxV - minV, 1);
  const gridN = 4;

  for(let i=0;i<=gridN;i++){
    const y = y0 + (innerH*(i/gridN));
    ctx.beginPath();
    ctx.moveTo(x0,y);
    ctx.lineTo(x1,y);
    ctx.stroke();

    const v = (maxV - span*(i/gridN));
    ctx.fillStyle = muted;
    ctx.font = "12px system-ui";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.fillText(formatAxis(v), x0-8, y);
  }

  ctx.fillStyle = fg;
  ctx.font = "16px system-ui";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  ctx.fillText(title, x0, 2);

  const n = labels.length;
  if(n===0){
    drawEmptyChart("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö");
    return;
  }

  const xAt = (i)=> x0 + (n===1 ? innerW/2 : innerW*(i/(n-1)));
  const yAt = (v)=> y0 + innerH*( (maxV - v)/span );

  ctx.strokeStyle = getVar("--accent");
  ctx.lineWidth = 2;
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const x = xAt(i);
    const y = yAt(values[i]||0);
    if(i===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }
  ctx.stroke();

  ctx.fillStyle = getVar("--accent");
  for(let i=0;i<n;i++){
    const x = xAt(i), y = yAt(values[i]||0);
    ctx.beginPath();
    ctx.arc(x,y,3,0,Math.PI*2);
    ctx.fill();
  }

  ctx.fillStyle = muted;
  ctx.font = "12px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  const show = Math.min(n, 3);
  for(let k=0;k<show;k++){
    const i = n - show + k;
    const x = xAt(i);
    ctx.fillText(labels[i], x, y1 + 10);
  }
}

function formatAxis(v){
  if(v>=1000) return Math.round(v/100)/10 + "k";
  return String(Math.round(v));
}
function getVar(name){
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

/* ===========================
   Escape helpers
=========================== */
function escapeHtml(s){
  return String(s??"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;");
}
function escapeAttr(s){
  return escapeHtml(s).replaceAll("'","&#39;");
}

/* ===========================
   –†–µ–Ω–¥–µ—Ä –≤—Å–µ–≥–æ + init
=========================== */
function renderAll(){
  renderTable();
  refreshMenuSelects();
  if(viewAnalytics.classList.contains("active")) renderAnalytics();
}
renderAll();

refreshAnalyticsSelects();

document.addEventListener("keydown", (e)=>{
  if(e.key==="Escape"){
    closeDrawer();
    closeCellEditor();
    closeInfo();
  }
});
</script>
</body>
</html>
